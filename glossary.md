### Глоссарий

* **Абстрактная операция** - операция, которая объявляет сигнатуру, но не реализует её. В `C++` абстрактные операции
  соответствуют чисто виртуальным функциям классов. В `PHP` нет непосредственного эквивалента абстрактной операции или
  чисто виртуальной функции, но возможно создать похожий функционал с использованием `abstract` и `interface`.

    - Представь, что абстрактная операция — это как задание на рисунок в раскраске. Ты видишь контур, который
      показывает, что нужно раскрасить, но сам рисунок ещё не раскрашен. Кто-то другой должен взять карандаши и
      раскрасить его. В программировании абстрактная операция — это задание: "Вот что нужно сделать" (контур), но оно не
      говорит, как это сделать (не раскрашено). Другие программисты или части программы сами решают, как выполнить это
      задание (как раскрасить).


* **Абстрактная связанность** - говорят, что класс `A` абстрактно связан с абстрактным классом `B`, если в `A` есть
  ссылка на `B`. Такое отношение мы называем абстрактной связанностью, поскольку `A` ссылается на тип объекта, а не на
  конкретный объект. В `PHP` абстрактная связанность работает через абстрактные классы и интерфейсы. Когда класс в `PHP`
  ссылается на абстрактный класс или интерфейс, это означает, что он не знает, с каким именно конкретным объектом он
  будет работать, но знает, какие методы у этого объекта должны быть. Это и есть абстрактная связанность.

    - Представь, что у тебя есть коробка с игрушками, и ты знаешь, что в ней лежит какая-то игрушка, но ты не знаешь,
      какая именно — машинка или кукла. Однако ты точно знаешь, что с ней можно играть, потому что все игрушки умеют
      развлекать.
    - Так вот, абстрактная связанность в программировании — это как эта коробка. Программа знает, что в коробке будет
      какой-то объект (например, игрушка), но не знает, какой именно. Она только уверена, что у этого объекта есть
      нужные "игрушечные" функции.


* **Абстрактный класс** - класс, единственным назначением которого является определение интерфейса. Абстрактный класс
  полностью или частично делегирует свою реализацию подклассам. Создавать экземпляры абстрактного класса нельзя. В `PHP`
  абстрактный класс — это класс, который нельзя использовать напрямую для создания объектов. Его основная цель — задать
  общие правила (интерфейс) для других классов. Абстрактный класс может содержать как полностью реализованные методы,
  так и абстрактные методы, которые должны быть реализованы в дочерних классах.

    - Представь, что абстрактный класс — это как план для строительства домов. Ты не можешь жить в этом плане, но можешь
      использовать его, чтобы строить разные дома. В плане сказано, что каждый дом должен иметь двери, окна и крышу, но
      как именно они будут выглядеть — решают строители.
    - В программировании абстрактный класс — это такой план. Он говорит, что другие классы должны делать определённые
      вещи (например, открывать двери или окна), но не объясняет, как это делать. Остальные классы сами решают, как
      именно реализовать эти действия, основываясь на общем плане.


* **Агрегированный объект** - объект, составленный из подобъектов. Подобъекты называются частями агрегата, и агрегат
  отвечает за них. В `PHP` концепция агрегированного объекта реализуется через композицию, где один объект содержит в
  себе
  другие объекты. Эти внутренние объекты называются частями агрегата, и агрегат (внешний объект) управляет ими.

    - Представь, что у тебя есть конструктор LEGO, и ты строишь большой замок. Замок состоит из разных частей, таких как
      стены, башни и ворота. Каждая из этих частей (стены, башни, ворота) — это как маленькие детали конструктора.
    - Агрегированный объект — это как этот замок. Замок сам по себе является большим объектом, но он состоит из
      маленьких
      деталей, которые называются частями агрегата. Замок управляет этими частями: он соединяет их вместе и делает так,
      чтобы
      они работали как единое целое.
    - В программировании это работает так же. Когда мы создаём объект (например, замок), мы можем вложить в него другие
      объекты (например, стены и башни). Этот большой объект управляет всеми маленькими объектами внутри себя, и все они
      работают вместе.


* **Делегирование** - механизм реализации, при котором объект перенаправляет или делегирует запрос другому объекту (
  уполномоченному). Уполномоченный выполняет запрос от имени исходного объекта. В PHP делегирование реализуется через
  передачу задач одному объекту от другого объекта. Это позволяет одному объекту выполнять запросы или задачи с помощью
  другого объекта, который более подходящ для выполнения этих задач.

    - Представь, что ты хочешь сделать домашнее задание, но у тебя нет всех нужных инструментов. Например, тебе нужно
      распечатать работу, но у тебя нет принтера. Ты просишь своего старшего брата или сестру, у которых есть принтер,
      помочь тебе. Они берут твое задание и печатают его за тебя.
    - Делегирование в программировании работает так же. Когда один объект (ты) не может что-то сделать сам, он просит
      другого объект (старшего брата или сестру) помочь и сделать это за него.


* **Деструктор** - в `C++` это операция, которая автоматически вызывается для очистки объекта непосредственно перед его
  удалением. В `PHP` деструктор — это специальный метод `__destruct()`, который автоматически вызывается, когда объект
  больше не нужен и
  его необходимо удалить. Деструктор используется для выполнения очистки или освобождения ресурсов, связанных с
  объектом, перед тем как он будет уничтожен.

    - Представь, что у тебя есть игрушка, и ты решил поиграть с ней, но после игры нужно убрать её на место.
    - Деструктор — это как напоминание о том, что нужно убрать игрушку после игры. Когда ты закончил играть, ты ставишь
      игрушку обратно на полку. Этот процесс напоминает деструктор в программировании, который автоматически убирает все
      ненужные вещи (ресурсы), когда объект больше не нужен.


* **Динамическое связывание** - ассоциация между запросом к объекту и одной из ее операций, устанавливаемая во время
  выполнения. В `C++` динамически связываться могут только виртуальные функции. В `PHP` динамическое связывание (или
  позднее связывание) означает, что решение о том, какой метод объекта вызвать, принимается во время выполнения
  программы, а не во время компиляции. В `PHP` это связано с использованием методов, которые могут быть переопределены в
  дочерних классах.

    - Представь, что у тебя есть коробка с игрушками, и в коробке есть разные игрушки: машинки, куклы и роботы. Каждая
      игрушка может издавать свой звук, когда ты на неё нажимаешь. Когда ты нажимаешь на кнопку, игрушка решает, какой
      именно звук сделать (например, машинка гудит, кукла поёт, а робот говорит что-то смешное). Это решение принимается
      в момент нажатия на кнопку, а не заранее.
    - В программировании динамическое связывание работает так же. Когда программа запускается, она решает, какой метод (
      или действие) выполнить, в зависимости от типа объекта, который используется. Это решение принимается во время
      выполнения программы, а не заранее, что делает программу гибкой и способной адаптироваться к разным ситуациям.


* **Дружественный класс** - в `C++` класс обладающий теме же правами доступа к операциям и данным некоторого класса, что
  и сам этот класс. В PHP концепция дружественного класса, как это реализовано в `C++`, отсутствует. В` C++`
  дружественный класс может получить доступ к закрытым и защищённым членам другого класса. В `PHP` можно добиться
  аналогичного поведения с помощью методов или свойств класса, которые предоставляют доступ к защищённым данным другим
  классам. Один из способов — это использование методов-получателей `(getter)` и методов-сеттеров `(setter)` для
  управления доступом.

    - Представь, что у тебя есть секретная коробка с игрушками, и только ты можешь открывать её и играть с содержимым.
    - Дружественный класс в C++ — это как если бы ты дал твоему другу специальный ключ, чтобы он мог тоже открывать
      коробку и играть с игрушками, так же как и ты. Этот друг знает все секреты коробки, как и ты.
    - В PHP нет такого специального ключа, как в C++. Но ты можешь сделать так, чтобы другие могли увидеть или
      использовать игрушки из коробки, просто показывая их через маленькое окошко или используя специальные инструкции.
        1. Ты создаёшь окошко или инструкцию (методы-получатели или методы-сеттеры), через которое другие могут увидеть
           или использовать содержимое коробки.
        2. Другие люди могут использовать это окошко или инструкции, чтобы получить доступ к игрушкам в коробке, но не
           могут открыть коробку сами.
    - Так что, хотя в PHP нет прямого способа дать другому классу такие же права, как у тебя, можно сделать так, чтобы
      они могли использовать содержимое коробки через специально подготовленные методы.


* **Закрытое наследование** - с `C++` класс, наследуемый только ради реализации. В PHP закрытого наследования, как в
  `C++,` нет. В `C++` закрытое наследование позволяет дочернему классу наследовать функциональность базового класса, но
  не
  позволяет использовать базовый класс как публичный интерфейс. То есть закрытое наследование ограничивает доступ к
  унаследованным методам и свойствам. В `PHP` наследование работает через ключевое слово extends, и все методы и
  свойства
  базового класса, кроме приватных, доступны в дочернем классе, но `PHP` не поддерживает закрытое наследование как
  в `C++`. Если вы хотите ограничить доступ к методам или свойствам в `PHP`, вы можете использовать уровни доступа:
  `protected` (для ограничения доступа к членам только в текущем классе и его наследниках) или `private` (для полного
  ограничения доступа вне класса).

    - Представь, что ты строишь дом, и у тебя есть чертеж (план), который помогает тебе строить. Этот чертеж — как
      базовый класс.
    - В закрытом наследовании (в C++) ты можешь использовать чертеж, чтобы построить дом, но другим людям нельзя
      показывать этот чертеж. Только ты знаешь, как по нему строить, но никто другой не может его увидеть или
      использовать.
    - Представь, что ты строишь дом, и у тебя есть чертеж (план), который помогает тебе строить. Этот чертеж — как
      базовый класс.
    - В закрытом наследовании (в C++) ты можешь использовать чертеж, чтобы построить дом, но другим людям нельзя
      показывать этот чертеж. Только ты знаешь, как по нему строить, но никто другой не может его увидеть или
      использовать.
    - В PHP нет такой функции, где можно скрыть чертеж. Когда ты строишь дом по плану (наследуешь базовый класс), все
      части плана, кроме самых секретных (приватных), могут быть видны и доступны.
    - Но ты можешь контролировать, что можно показывать другим людям:
        1. protected — это как часть плана, которую могут видеть только ты и твои близкие друзья (дочерние классы).
        2. private — это суперсекретная часть, которую никто, кроме тебя, не может использовать.


* **Замещение** - Переопределение операции, унаследованной от родительского класса, в подклассе. В PHP замещение
  называется переопределением метода. Когда дочерний класс наследует метод от родительского класса, он может изменить
  его, создав свою версию этого метода.

    - Представь, что у тебя есть любимый рецепт пирога, который ты узнал от своей мамы. Но когда ты сам печешь пирог, ты
      решаешь добавить что-то новое, например, больше шоколада. Это твоя версия пирога, хотя ты взял рецепт у мамы.
    - В программировании это называется замещением. Мама (родительский класс) дала тебе рецепт (метод), но ты можешь его
      изменить по своему вкусу (переопределить метод в дочернем классе).


* **Инкапсуляция** - результат сокрытия представления и реализации в объекте. Представление не видимо и недоступно из
  вне. Получить доступ к представлению объекта и модифицировать его можно только с помощью операций. В PHP инкапсуляция
  работает так же, как и в других языках: это способ скрыть внутренние детали объекта и разрешить доступ к ним только
  через специальные методы и достигается с помощью модификаторов доступа: private — только сам объект может использовать
  эти данные, protected — доступ разрешен только этому классу и его потомкам (наследникам), public — данные доступны
  всем.

    - Представь, что у тебя есть коробка с замком, и никто не может заглянуть внутрь или достать что-то напрямую. Только
      ты
      знаешь, где ключ, и можешь открыть коробку, чтобы положить туда что-то или взять. В программировании коробка — это
      объект, а замок — это способ скрыть детали (инкапсуляция). Люди могут пользоваться только специальными ключами (
      методами), чтобы взаимодействовать с содержимым коробки.
    - Сеттеры и геттеры — это специальные методы, которые помогают управлять доступом к данным внутри объекта. Геттер —
      это
      метод, который получает (возвращает) значение какого-то свойства объекта. Сеттер — это метод, который
      устанавливает (
      изменяет) значение свойства объекта.
    - Представь, что у тебя есть коробка с игрушкой, но она закрыта. Ты не можешь просто так залезть в коробку, тебе
      нужно
      попросить маму (геттер) показать тебе игрушку. А если ты хочешь поменять игрушку внутри, ты снова обращаешься к
      маме (
      сеттер), и она поменяет игрушку за тебя.


* **Инструментальная библиотека (toolkit)** - набор классов, обеспечивающих полезную функциональность, но не
  определяющих дизайн приложения. В PHP инструментальная библиотека — это набор классов и функций, которые помогают
  программисту выполнять определенные задачи, не задавая общий дизайн приложения. Инструментальные библиотеки могут
  содержать классы для работы с датами, отправки электронной почты, обработки изображений и так далее. Например,
  библиотека Guzzle используется для работы с HTTP-запросами, а библиотека Carbon — для работы с датами и временем.

    - то как ящик с инструментами, где каждый инструмент (класс или функция) предназначен для выполнения какой-то
      полезной
      работы. Эти инструменты можно использовать по мере необходимости, не следуя каким-то строгим правилам.


* **Интерфейс** - набор всех сигнатур, определенных операциями объекта. Интерфейс описывает множество
  запросов, на которые может отвечать объект. В PHP интерфейс — это набор правил, которые указывают, какие методы должен
  иметь класс, но не определяют, как именно эти методы должны работать. Интерфейс описывает только сигнатуры методов, то
  есть их имена и параметры, но не их реализацию. Классы, которые "реализуют" интерфейс, обязаны предоставить
  собственную реализацию всех методов, определённых в интерфейсе. Интерфейс является отдельным типом данных в PHP и
  может участвовать в типизации аргументов и возвращаемых значений методов. Это означает, что можно указать, что метод
  принимает или возвращает объект, который реализует определённый интерфейс. PHP поддерживает реализацию нескольких
  интерфейсов в одном классе, что позволяет классам обладать функциональностью, описанной в разных интерфейсах, и
  эффективно использовать множественное наследование через интерфейсы.

    - Представь, что интерфейс — это как список правил для игр. В правилах сказано: "Ты должен уметь играть, но не
      сказано,
      как именно играть". Например, машинка и кукла могут играть по-разному, но обе должны уметь это делать. В
      программировании интерфейс — это такой список правил, который говорит: "У объекта должен быть этот метод", а как
      именно он будет работать, решает сам объект.


* **Каркас** - набор взаимодействующих классов, описывающих повторно применимый дизайн некоторой категории программ.
  Каркас задает архитектуру приложения, разбивая ее на отдельные классы с четко определенными функциями и
  взаимодействиями. Разработчик настраивает каркас под конкретное предложение путем порождения подклассов и составления
  композиций из объектов, принадлежащих классам каркаса. В PHP каркас (или framework) представлен различными
  фреймворками, такими как Laravel, Symfony, Yii и другие. Эти фреймворки предоставляют основу для разработки
  приложений: они определяют структуру проекта, маршрутизацию, работу с базами данных и другие важные элементы.
  Программисты настраивают фреймворк для своих приложений, создавая свои классы, расширяя и изменяя функциональность по
  необходимости.

    - Представь, что ты строишь дом. Каркас — это уже готовая основа дома, с уже построенными стенами и крышей, но без
      мебели и украшений. Ты можешь добавить свои комнаты, покрасить стены в любимый цвет и расставить мебель по своему
      вкусу. Фреймворк в программировании — это как такой дом. Он даёт тебе уже готовые стены и крышу (основную
      структуру),
      а ты добавляешь туда свои вещи (код), чтобы всё работало так, как тебе нужно.


* **Класс** - определяет интерфейс и реализацию объекта. Описывает внутренние представление и операции, которые объект
  может выполнять. В PHP класс определяет, какими характеристиками будет обладать объект и какие действия этот объект
  сможет выполнять. Программист создаёт класс, а затем на основе этого класса можно создавать много объектов, которые
  будут работать по этим правилам.

    - Представь, что класс — это как инструкция для создания игрушки. В инструкции написано, что у игрушки есть колёса и
      мотор (это свойства), и что она может ездить и гудеть (это методы). Ты можешь создать много таких игрушек, каждая
      будет сделана по этой инструкции.

* **Композиция объектов** - объединение нескольких объектов для получения более сложного поведения. В PHP композиция
  реализуется тем, что один класс содержит внутри себя объекты других классов. Вместо того чтобы наследовать свойства и
  методы другого класса, мы просто включаем эти объекты как части сложного объекта.

- Представь, что ты строишь робот. У робота есть разные части: голова, руки и ноги. Каждая часть может что-то делать —
  руки могут хватать, ноги могут ходить. Вместе, как одна команда, они делают робота сильнее. Вот это и есть композиция:
  робот сам по себе не может ни ходить, ни хватать, но благодаря своим частям он может делать все эти вещи.


* **Конкретный класс** - класс, в котором нет абстрактных операций. Может иметь экземпляры. В PHP конкретный класс — это
  обычный класс, в котором все методы полностью реализованы. Это класс, от которого можно создавать объекты напрямую. Он
  не содержит абстрактных методов и не требует, чтобы его подклассы что-то дорабатывали.

- Представь, что ты строишь дом. Конкретный класс — это уже готовый дом, в котором есть двери, окна, крыша и все
  остальное. Ты можешь сразу въехать в него и начать жить. Ничего больше не нужно достраивать или менять.


* **Конструктор** - в C++ операция, автоматически вызывающаяся для инициализации новых экземпляров. В PHP конструктор —
  это метод __construct(). Когда вы создаете новый объект класса, конструктор автоматически вызывается и подготавливает
  объект к работе, например, устанавливая начальные значения для его свойств.

- Представь, что ты покупаешь игрушку, и она упакована в коробку. Когда ты открываешь коробку, кто-то уже заранее
  положил в неё батарейки, чтобы игрушка могла сразу работать. Конструктор — это тот, кто кладёт батарейки, когда
  игрушка создаётся.


* **Рефлексия** — это способность программы исследовать и изменять свою структуру и поведение во время выполнения. В PHP
  рефлексия позволяет получать информацию о классах, методах, свойствах и даже вызывать методы динамически.

- Представь, что у тебя есть коробка с игрушками, но ты не знаешь, что внутри. Рефлексия — это как волшебное стекло, с
  помощью которого ты можешь заглянуть внутрь коробки и узнать, какая там игрушка, какие у неё кнопки или рычажки. А
  потом ты можешь решить, на какую кнопку нажать, даже если раньше не знал, что такая кнопка существует.


* **Метакласс** - в Smalltalk классы являются объектами. Метакласс - это класс объекта-класса. В PHP концепции
  метаклассов, как в Smalltalk, нет. Однако классы в PHP тоже можно рассматривать как объекты благодаря механизму
  рефлексии. С помощью рефлексии в PHP можно узнать информацию о классе (его свойства, методы и т.д.) или динамически
  вызывать методы класса.

- Представь, что у тебя есть домик для кукол, и каждая кукла в этом домике живёт по своим правилам. Теперь, представь,
  что у тебя есть книга, в которой записано всё о каждой кукле: что она умеет делать, что ей нравится, и что она может.
  Так вот, метакласс — это как эта книга про кукол. Он знает всё про куклы и может рассказать, что каждая из них умеет
  делать.
- В PHP нет таких книг (метаклассов) напрямую, как в некоторых других языках, но ты всё равно можешь заглянуть в
  кукольную книгу с помощью волшебного инструмента — рефлексии. Это помогает узнать, что может кукла (класс) и какие у
  неё есть свойства и действия.


* **Наследование** - отношение, которое определяет одну сущность в терминах другой. В случае наследования класса новый
  класс определяется в терминах одного или нескольких родительских классов. Новый класс наследует интерфейс и реализацию
  от своих родителей. Новый класс называется подклассом или производным классом в C++. Наследование класса объединяет
  наследование интерфейса и наследование реализации. В случае наследования интерфейса новый интерфейс определяется в
  терминах одного или нескольких существующих. При наследовании реализации новая реализация определяется в терминах в
  одной или нескольких существующих. В PHP наследование реализуется с помощью ключевого слова extends. Дочерний класс
  может использовать свойства и методы родительского класса, а также может добавлять свои собственные или изменять
  унаследованные.

- Представь, что родительский класс — это как родитель, который может передавать своим детям умения. Например, если
  родитель умеет ездить на велосипеде, его ребёнок тоже может научиться этому автоматически. Но ребёнок может добавить
  свои собственные умения, например, прыгать на батуте. Наследование в программировании — это когда один класс
  получает "наследство" от другого и может использовать это или изменить по-своему.


* **Объект** - имеющаяся во время выполнения сущность, в которой хранятся данные и процедуры для работы с ними. В PHP
  объекты создаются на основе классов. Каждый объект является экземпляром какого-либо класса, содержащего инструкции о
  том, как этот объект должен выглядеть и что он может делать.

    - Представь, что класс — это как рецепт, по которому можно сделать торт. В рецепте написано, какие ингредиенты
      нужны (
      данные) и как их смешивать (действия). А торт, который ты сделаешь по этому рецепту, — это объект.


* **Операция** - на данные объекта можно воздействовать только с помощью его операций. Объект выполняет операцию, когда
  получает запрос. В C++ операции называются функциями класса, в SmallTalk методами. В PHP операции называются методами
  класса. Это функции, которые принадлежат классу и работают с данными (свойствами) объекта. Методы могут изменять эти
  данные или возвращать их.

    - Представь, что у тебя есть робот, и у него есть кнопки, с помощью которых ты говоришь ему, что делать. Эти
      кнопки —
      это методы. Ты нажимаешь на кнопку "ходи", и робот начинает двигаться. Но ты не можешь двигать его сам, только с
      помощью кнопок.


* **Операция класса** - операция, определенная для класса в целом, а не для индивидуального объекта. В C++ операции
  класса называются статическими функциями. В PHP операции класса называются статическими методами. Статические методы
  принадлежат классу в целом, а не отдельным его экземплярам. Их можно вызывать без создания объекта класса.

    - Представь, что есть фабрика, которая делает машинки. У этой фабрики есть специальная кнопка, которая, когда на неё
      нажимают, показывает, сколько всего машинок было сделано. Кнопка — это как операция класса, потому что она
      относится
      ко всей фабрике, а не к отдельной машинке.


* **Отношение агрегирования** - отношение агрегата и его частей. Класс определяет такое отношение для своих экземпляров,
  то есть агрегированных объектов. Это когда один объект состоит из нескольких других, и он управляет этими частями. В
  PHP это реализуется через композицию или агрегацию, где один класс содержит объекты других классов. Агрегат (главный
  объект) не создаёт свои части сам, а получает их извне. Он может управлять ими, но если его уничтожить, его части
  могут продолжать существовать.

    - Представь, что машина — это игрушка, а двигатель — батарейка. Игрушка не может работать без батарейки. Игрушка
      управляет батарейкой и использует её, чтобы двигаться. Это как если бы машина была главным объектом (агрегатом), а
      двигатель — её частью. Машина может использовать двигатель, но если двигатель убрать, он всё равно может работать
      в
      другой машине.


* **Отношение осведомленности** - говорят, что одному классу известно о другом, если первый ссылается на второй. В PHP
  это происходит, когда один класс включает в себя объекты или методы другого класса, используя их в своей работе.

    - Представь, что у тебя есть игрушечная машина. Чтобы она поехала, тебе нужно знать, как завести её мотор (
      двигатель).
      Машина "знает" о моторе и использует его, чтобы двигаться. Это как если бы машина (один класс) знала, что у неё
      есть
      мотор (другой класс), и использовала его, чтобы работать.


* **Паттерн проектирования** - паттерн проектирования именует, мотивирует и объясняет конкретный прием проектирования,
  который относится к задаче, часто возникающей при работе над объектно-ориентированными системами. Паттерн описывает
  задачу, ее решение, область применимости этого решения и его результаты. Он также содержит рекомендации по реализации
  и примеры. Под решением понимается схема организации объектов и классов, позволяющая справится с проблемой. Паттерн
  адаптируется для работы в конкретных условиях и реализуется в заданном контексте. Паттерн проектирования — это
  проверенный способ решения часто возникающей задачи при создании программ. Он описывает проблему, предлагает схему,
  как её решить, и объясняет, когда этот способ подходит лучше всего. Паттерн включает примеры и советы, как лучше его
  использовать. Это как универсальный рецепт, который программисты могут адаптировать для своих нужд, чтобы быстрее и
  проще решать задачи.

    - Представь, что ты учишься готовить пирог. У тебя есть рецепт, который объясняет, какие ингредиенты нужны, как их
      смешивать, и сколько времени выпекать пирог. Рецепт — это как "паттерн проектирования" в программировании. Ты
      можешь
      использовать этот рецепт, чтобы готовить разные пироги, но иногда добавляешь что-то своё, чтобы сделать его
      уникальным. Так и программисты используют паттерны как готовые рецепты для своих программ, но могут немного их
      изменить, если нужно.


* **Переменная экземпляра** - элемент данных, определяющей часть представления объекта. в C++ используется термин
  переменная класса, а в PHP — свойством объекта. Каждая переменная экземпляра уникальна для каждого созданного объекта
  и хранит его индивидуальные данные.

    - Представь, что у тебя есть коробка для игрушек, и у каждого из твоих друзей есть своя коробка. У тебя в коробке
      лежит машинка, а у друга — кукла. Коробки — это объекты, а игрушки внутри — это переменные экземпляра. Каждая
      коробка (объект) хранит свои вещи (переменные), которые могут быть разными для каждого человека.


* **Подкласс** - класс, наследующий другому классу. В C++ подкласс называется производным классом. Это класс,
  который наследует другой класс. В PHP подклассы создаются с помощью ключевого слова extends. Подкласс наследует
  свойства и методы родительского класса, но может также добавлять свои собственные методы или изменять поведение
  унаследованных.

    - Представь, что есть большой конструктор, который может собирать разные машины. Этот большой конструктор — это как
      родительский класс. Теперь ты можешь создать другой, меньший конструктор, который собирает только спортивные
      машины. Этот маленький конструктор — это подкласс. Он умеет всё то, что и большой конструктор (собирать машины),
      но может добавить что-то своё, например, улучшенные спортивные колёса.


* **Подсистема** - независимая группа классов, функционирующих совместно для выполнения набора обязанностей.
  Это независимая группа классов, которые работают вместе, чтобы выполнить определённые задачи. Подсистема
  обычно скрывает сложные детали работы этих классов и предоставляет простой интерфейс для взаимодействия с другими
  частями программы.

    - Представь, что у тебя есть робот-пылесос. Внутри него работают разные части: мотор для движения, щётки для уборки,
      батарея для питания. Все эти части вместе — это как подсистема, которая делает уборку. Ты просто нажимаешь кнопку,
      и робот начинает убираться, не нужно знать, как работает каждая часть внутри.


* **Подтип** - один тип называется подтипом другого, если интерфейс первого содержит интерфейс второго. В PHP это
  реализуется через наследование и интерфейсы. Когда один класс наследует другой или реализует интерфейс, он становится
  подтипом этого класса или интерфейса. Подтип может выполнять все действия, которые доступны для родительского типа, но
  может иметь и дополнительные функции.

    - Представь, что у тебя есть игрушка — машинка. А потом ты покупаешь машинку с пультом управления. Машинка с
      пультом — это как подтип обычной машинки. Она умеет делать всё, что и обычная (ездить), но у неё есть ещё и новые
      способности — ты можешь управлять ею с пульта.


* **Полиморфизм** - способность поставлять во время выполнения в место одного другой с совместимым интерфейсом.
  Это способность объекта использовать методы других объектов, если они имеют одинаковый интерфейс или
  наследуют один и тот же базовый класс. В PHP полиморфизм реализуется через интерфейсы и наследование. Класс может
  реализовать интерфейс или наследовать другой класс, и тогда объект этого класса может быть использован вместо любого
  другого объекта с совместимым интерфейсом или родителем.

    - Представь, что у тебя есть несколько разных видов машинок — игрушечная машинка и машинка с пультом. У них обеих
      есть кнопка, чтобы ехать вперёд. Ты можешь нажимать на эту кнопку и они поедут, даже если это разные машинки. Это
      как полиморфизм в программировании: разные объекты могут делать одно и то же, если у них есть одинаковая кнопка (
      метод).


* **Получатель** - объект которому направлен запрос. Это объект, которому отправляется запрос на выполнение определённой
  операции. Когда один объект хочет, чтобы другой объект что-то сделал, он направляет этому объекту запрос. Получатель —
  это тот, кто обрабатывает этот запрос и выполняет нужные действия.

    - Представь, что ты хочешь, чтобы робот принёс тебе игрушку. Ты говоришь роботу: «Принеси мне игрушку!». Робот — это
      получатель твоего запроса, и он выполняет твою просьбу, потому что знает, как это сделать.


* **Примесь** - класс, спроектированный так, что бы сочетаться с другими классами путем наследования. Примеси-классы
  обычно абстрактны. Это класс, который создаётся для того, чтобы его возможности можно было добавлять к другим классам
  через наследование. Примеси обычно не используются сами по себе, а служат для расширения функциональности других
  классов. В примеси могут быть методы и свойства, которые потом могут использоваться в классах, наследующих её. В PHP
  примеси реализуются с помощью трейтов. Трейт позволяет добавлять методы в разные классы, чтобы не повторять код.

    - Представь, что у тебя есть робот, который умеет ходить, и ты хочешь, чтобы он ещё научился петь. Ты можешь дать
      роботу «умение петь» (это как примесь), и теперь он будет и ходить, и петь.


* **Прозрачный ящик как способ повторного использования** - стиль повторного использования, основанный на наследование
  классов. Подкласс второго использует интерфейс и реализацию родительского класса, но может так же иметь доступ
  закрытым для других аспектам своего родителя. В PHP наследование работает через ключевое слово extends. Подкласс
  наследует все открытые (public) и защищённые (protected) методы и свойства родительского класса. Это и есть механизм "
  прозрачного ящика", когда дочерний класс может "видеть" внутренние детали родительского класса, такие как защищённые
  методы и свойства.

    - Представь, что ты умеешь кататься на велосипеде, и твой младший брат хочет тоже научиться. Ты показываешь ему, как
      крутить педали и держать руль. Это как если бы он повторно использовал твои знания (как ты учился) и теперь может
      кататься сам.


* **Протокол** - расширяет концепцию интерфейса за счет включения допустимой последовательности запросов. Это
  расширенная версия интерфейса, которая не только описывает набор методов (запросов), но и определяет, в каком порядке
  их можно вызывать. Это означает, что протокол описывает правильную последовательность взаимодействия с объектом, чтобы
  он работал корректно. В PHP нет прямого понятия протокола, но его концепция может быть реализована через интерфейсы и
  дополнительные соглашения о том, как использовать методы. Интерфейс в PHP определяет только сигнатуры методов, но
  разработчик сам должен следить за правильным порядком вызовов этих методов.

    - Представь, что у тебя есть инструкция к игрушечной машине. В инструкции написано: сначала надо включить машинку,
      потом можно начать ею управлять, и в конце выключить. Если ты перепутаешь порядок (например, начнёшь управлять до
      включения), машинка не поедет. Протокол — это как эта инструкция, где важно делать всё по порядку!


* **Родительский класс** - класс которому наследует другой класс. Синонимы: суперкласс (Smalltalk), базовый класс (С++)
  и класс-предок. В PHP его называют родительским классом или базовым классом. Класс, который наследует родительский,
  называется дочерним классом. Дочерний класс перенимает все свойства и методы родительского класса, но может
  переопределять их или добавлять свои.

    - Представь, что у тебя есть машина. Машина — это родитель, у неё есть колёса и руль. Теперь представь, что у тебя
      есть игрушечная машинка, которая унаследовала всё от настоящей машины — у неё тоже есть колёса и руль, но она
      умеет издавать другие звуки. Машинка может всё, что и настоящая машина, но по-своему!


* **Связанность** - Степень зависимости компонентов программы друг от друга. Чем сильнее связаны компоненты, тем больше
  они зависят друг от друга и сложнее изменить один компонент без необходимости менять другие. Чем слабее связаны
  компоненты, тем проще их модифицировать или использовать повторно. В PHP степень связанности между классами можно
  контролировать с помощью различных механизмов, таких как интерфейсы, абстракция и инъекция зависимостей. Стремятся к
  слабой связанности, чтобы компоненты системы были независимыми и легко изменяемыми.

    - Представь, что у тебя есть игрушки, и каждая игрушка — это отдельная деталь. Если все игрушки склеены вместе, и ты
      захочешь поменять одну, тебе придётся менять все остальные. Это как сильная связанность — все детали зависят друг
      от друга. А если игрушки не приклеены, ты можешь менять одну игрушку, не затрагивая другие. Это как слабая
      связанность — игрушки независимы друг от друга, и тебе проще играть.

* **Сигнатура** - под сигнатурой операции понимается сочетание ее имени, параметров и возвращаемого значения. Сигнатура
  определяет, как нужно вызывать метод или функцию, какие данные она ожидает и что возвращает в ответ. В PHP сигнатура
  метода или функции включает имя метода, параметры (с их типами, если указаны) и тип возвращаемого значения. Две
  функции с одинаковым именем, но разными параметрами имеют разные сигнатуры.

    - Представь, что ты заказываешь пиццу. Твоя «сигнатура» заказа — это твоё имя, какие ингредиенты ты хочешь, и размер
      пиццы. Если ты добавишь разные ингредиенты или выберешь другой размер, заказ изменится, как будто ты изменил
      «сигнатуру» метода, и пиццерия приготовит пиццу по твоему новому запросу.


* **Ссылка на объект** - значение, которое идентифицирует другой объект. В PHP ссылка на объект — это переменная,
  которая указывает на область памяти, где хранится объект. Это значит, что при передаче объекта в функцию или
  присвоении его другой переменной, на самом деле передается не сам объект, а ссылка на него.

    - Представь, что у тебя есть коробка с игрушкой, и ты дал другу карту с указанием, где лежит эта коробка. Карта —
      это как ссылка на коробку. Друг может использовать карту, чтобы найти коробку, но сама игрушка остается на том же
      месте.


* **Супертип** - тип родителя, которому наследует этот тип. В PHP супертипом может быть класс или интерфейс, от которого
  наследуются другие классы. Он определяет общий интерфейс и методы, которые затем могут быть унаследованы и
  использованы подклассами.

    - Представь, что супертип — это как общий план для всех видов машин. У каждой машины есть колеса и руль (это общие
      черты). А разные модели машин (подтипы) могут добавлять свои особенности, например, разные цвета или скорости, но
      все они будут иметь колеса и руль, потому что унаследовали их от плана (супертипа).

* **Схема взаимодействий** - схема, на которой показан поток запросов между объектами. Это схема, которая показывает,
  как объекты общаются друг с другом, какие запросы они отправляют и как реагируют на них. В программировании она
  помогает понять, как различные части программы (объекты) взаимодействуют для выполнения задач.

    - Представь, что это как план для команды супергероев. Каждый герой (объект) делает своё задание, но чтобы победить
      злодея, они должны помогать друг другу. На схеме показано, кто кому помогает и что передаёт (например, герой А
      отправляет сигнал герою Б, чтобы он использовал свои силы).

* **Схема классов** - схема на которой изображены классы. их внутрення структура и операции, а так же статические связи
  между ними. Это схема, на которой изображены классы программы, их внутренняя структура (например, свойства и методы) и
  связи между ними. Она показывает, как классы взаимодействуют и зависят друг от друга.

    - Представь, что это как карта большого города, где каждый дом — это класс. В каждом доме живут люди (данные) и они
      могут делать определённые вещи (операции). Схема показывает, как дома соединены дорогами (связи), и кто куда может
      пойти или позвонить за помощью.


* **Схема объекта** - схема на которой изображена структура конкретного объекта во время выполнения. На ней можно
  увидеть, какие данные содержит объект и как они связаны между собой в этот момент.

    - Представь, что это как рисунок твоей любимой игрушки-робота, на котором видно, какие у него детали внутри и что
      они делают прямо сейчас, когда ты его включил.


* **Тип** - имя конкретного интерфейса, который определяет, какие методы и свойства должен иметь класс. Тип помогает
  программе понять, какие операции можно выполнять с объектами.

    - Представь, что тип — это название определённой игрушки, например, «машинка». Когда ты знаешь, что у тебя есть
      «машинка», ты понимаешь, что она может двигаться, иметь колёса и звук двигателя. Таким образом, ты знаешь, что с
      ней можно делать!


* **Черный ящик как способ повторного использования** - стиль повторного использования, основанный на композиции
  объектов. Объекты-компоненты не раскрываю друг другу деталей своего внутреннего устройства и потому могут быть
  уподоблены черным ящикам. Это стиль повторного использования, основанный на композиции объектов. В этом подходе
  объекты-компоненты не раскрывают друг другу детали своего внутреннего устройства и могут рассматриваться как черные
  ящики. Это означает, что ты можешь использовать их, не зная, как они работают внутри. В PHP можно создать чёрный ящик,
  используя композицию. Например, класс может включать другие классы в качестве свойств, но не раскрывать их внутреннюю
  логику. Это позволяет разрабатывать модули, которые можно легко использовать в разных частях программы, не беспокоясь
  о том, как они реализованы.

    - Представь, что у тебя есть игрушечный конструктор. Каждый элемент конструктора — это как черный ящик: ты знаешь,
      что он соединяется с другими частями и может что-то построить, но ты не обязательно знаешь, как именно он работает
      внутри. Ты просто используешь его, чтобы создать свою игрушку!





























